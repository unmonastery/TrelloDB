// Generated by CoffeeScript 1.9.1
(function() {
  var TaskGroup, _, docpadUtil, extractOptsAndCallback, pathUtil, util,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice;

  pathUtil = require('path');

  util = require('util');

  _ = require('lodash');

  extractOptsAndCallback = require('extract-opts').extractOptsAndCallback;

  TaskGroup = require('taskgroup').TaskGroup;

  module.exports = docpadUtil = {
    writeStderr: function(data) {
      var err;
      try {
        return process.stderr.write(data);
      } catch (_error) {
        err = _error;
        return process.stdout.write(data);
      }
    },
    writeError: function(err) {
      var ref;
      return docpadUtil.writeStderr(((ref = err.stack) != null ? typeof ref.toString === "function" ? ref.toString() : void 0 : void 0) || err.message || err);
    },
    wait: function(time, fn) {
      return setTimeout(fn, time);
    },
    isTTY: function() {
      var ref, ref1;
      return ((ref = process.stdout) != null ? ref.isTTY : void 0) === true && ((ref1 = process.stderr) != null ? ref1.isTTY : void 0) === true;
    },
    inspect: function(obj, opts) {
      if (opts == null) {
        opts = {};
      }
      if (docpadUtil.isTTY()) {
        if (opts.colors == null) {
          opts.colors = indexOf.call(process.argv, '--no-colors') < 0;
        }
      } else {
        opts.colors = false;
      }
      return util.inspect(obj, opts);
    },
    isStandardEncoding: function(encoding) {
      var ref;
      return (ref = encoding.toLowerCase()) === 'ascii' || ref === 'utf8' || ref === 'utf-8';
    },
    getLocalDocPadExecutable: function() {
      return pathUtil.join(process.cwd(), 'node_modules', 'docpad', 'bin', 'docpad');
    },
    isLocalDocPadExecutable: function() {
      var ref;
      return ref = docpadUtil.getLocalDocPadExecutable(), indexOf.call(process.argv, ref) >= 0;
    },
    getLocalDocPadExecutableExistance: function() {
      return require('safefs').existsSync(docpadUtil.getLocalDocPadExecutable()) === true;
    },
    startLocalDocPadExecutable: function(next) {
      var args, command;
      args = process.argv.slice(2);
      command = ['node', docpadUtil.getLocalDocPadExecutable()].concat(args);
      return require('safeps').spawn(command, {
        stdio: 'inherit'
      }, function(err) {
        var message;
        if (err) {
          if (next) {
            return next(err);
          } else {
            message = 'An error occured within the child DocPad instance: ' + err.message + '\n';
            return docpadUtil.writeStderr(message);
          }
        } else {
          return typeof next === "function" ? next() : void 0;
        }
      });
    },
    getBasename: function(filename) {
      var basename;
      if (filename[0] === '.') {
        basename = filename.replace(/^(\.[^\.]+)\..*$/, '$1');
      } else {
        basename = filename.replace(/\..*$/, '');
      }
      return basename;
    },
    getExtensions: function(filename) {
      var extensions;
      extensions = filename.split(/\./g).slice(1);
      return extensions;
    },
    getExtension: function(extensions) {
      var extension;
      if (!require('typechecker').isArray(extensions)) {
        extensions = docpadUtil.getExtensions(extensions);
      }
      if (extensions.length !== 0) {
        extension = extensions.slice(-1)[0] || null;
      } else {
        extension = null;
      }
      return extension;
    },
    getDirPath: function(path) {
      return pathUtil.dirname(path) || '';
    },
    getFilename: function(path) {
      return pathUtil.basename(path);
    },
    getOutFilename: function(basename, extension) {
      if (basename === '.' + extension) {
        return basename;
      } else {
        return basename + (extension ? '.' + extension : '');
      }
    },
    getUrl: function(relativePath) {
      return '/' + relativePath.replace(/[\\]/g, '/');
    },
    getSlug: function(relativeBase) {
      return require('bal-util').generateSlugSync(relativeBase);
    },
    action: function(action, opts, next) {
      var actionMethod, actionTaskOrGroup, actions, err, i, len, locale, me, ref, ref1, ref2, run, runner, runnerTask, task;
      ref = extractOptsAndCallback(opts, next), opts = ref[0], next = ref[1];
      me = this;
      locale = me.getLocale();
      run = (ref1 = opts.run) != null ? ref1 : true;
      runner = (ref2 = opts.runner) != null ? ref2 : me.getActionRunner();
      if (Array.isArray(action)) {
        actions = action;
      } else {
        actions = action.split(/[,\s]+/g);
      }
      actions = _.uniq(_.compact(actions));
      if (actions.length === 0) {
        err = new Error(locale.actionEmpty);
        return next(err);
        me;
      }
      if (actions.length > 1) {
        actionTaskOrGroup = runner.createGroup('actions bundle: ' + actions.join(' '));
        for (i = 0, len = actions.length; i < len; i++) {
          action = actions[i];
          actionMethod = me[action].bind(me);
          if (!actionMethod) {
            err = new Error(util.format(locale.actionNonexistant, action));
            return next(err);
            me;
          }
          task = actionTaskOrGroup.createTask(action, actionMethod, {
            args: [opts]
          });
          actionTaskOrGroup.addTask(task);
        }
      } else {
        action = actions[0];
        actionMethod = me[action].bind(me);
        if (!actionMethod) {
          err = new Error(util.format(locale.actionNonexistant, action));
          return next(err);
          me;
        }
        actionTaskOrGroup = runner.createTask(action, actionMethod, {
          args: [opts]
        });
      }
      runnerTask = runner.createTask("runner task for action: " + action, function(continueWithRunner) {
        actionTaskOrGroup.done(function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          if (next) {
            next.apply(null, args);
            args[0] = null;
          }
          return continueWithRunner.apply(null, args);
        });
        return actionTaskOrGroup.run();
      });
      runner.addTask(runnerTask);
      if (run === true) {
        runner.run();
      }
      return me;
    }
  };

}).call(this);
